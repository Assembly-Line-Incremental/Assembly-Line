"use client";

import { useEffect, useRef, type ReactNode } from "react";

interface ScrollRevealProps {
	children: ReactNode;
	className?: string;
	delay?: number;
	direction?: "up" | "down" | "left" | "right" | "none";
	distance?: number;
	duration?: number;
	once?: boolean;
}

export function ScrollReveal({
	children,
	className = "",
	delay = 0,
	direction = "up",
	distance = 32,
	duration = 700,
	once = true,
}: ScrollRevealProps) {
	const ref = useRef<HTMLDivElement>(null);

	useEffect(() => {
		const el = ref.current;
		/* istanbul ignore next -- @preserve */
		if (!el) return;

		const translate = {
			up: `translateY(${distance}px)`,
			down: `translateY(-${distance}px)`,
			left: `translateX(${distance}px)`,
			right: `translateX(-${distance}px)`,
			none: "none",
		};

		el.style.opacity = "0";
		el.style.transform = translate[direction];
		el.style.transition = `opacity ${duration}ms cubic-bezier(0.16, 1, 0.3, 1) ${delay}ms, transform ${duration}ms cubic-bezier(0.16, 1, 0.3, 1) ${delay}ms`;

		const observer = new IntersectionObserver(
			([entry]) => {
				if (entry.isIntersecting) {
					el.style.opacity = "1";
					el.style.transform = "none";
					if (once) observer.unobserve(el);
				} else if (!once) {
					el.style.opacity = "0";
					el.style.transform = translate[direction];
				}
			},
			{ threshold: 0.15, rootMargin: "0px 0px -40px 0px" }
		);

		observer.observe(el);
		return () => observer.disconnect();
	}, [delay, direction, distance, duration, once]);

	return (
		<div ref={ref} className={className}>
			{children}
		</div>
	);
}
